### This file was generated by Nexus Schema
### Do not make changes to this file directly


type Alarm {
  group: Group!
  id: Int!
  message: String!
  user: User!
}

input AlarmCreateInput {
  group: GroupCreateOneWithoutAlarmsInput!
  message: String!
  user: UserCreateOneWithoutAlarmsInput!
}

input AlarmCreateManyWithoutGroupInput {
  connect: [AlarmWhereUniqueInput!]
  create: [AlarmCreateWithoutGroupInput!]
}

input AlarmCreateManyWithoutUserInput {
  connect: [AlarmWhereUniqueInput!]
  create: [AlarmCreateWithoutUserInput!]
}

input AlarmCreateWithoutGroupInput {
  message: String!
  user: UserCreateOneWithoutAlarmsInput!
}

input AlarmCreateWithoutUserInput {
  group: GroupCreateOneWithoutAlarmsInput!
  message: String!
}

input AlarmListRelationFilter {
  every: AlarmWhereInput
  none: AlarmWhereInput
  some: AlarmWhereInput
}

input AlarmWhereInput {
  AND: [AlarmWhereInput!]
  group: GroupWhereInput
  groupId: IntFilter
  id: IntFilter
  message: StringFilter
  NOT: [AlarmWhereInput!]
  OR: [AlarmWhereInput!]
  user: UserWhereInput
  userId: IntFilter
}

input AlarmWhereUniqueInput {
  id: Int
}

"""
A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the
`date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO
8601 standard for representation of dates and times using the Gregorian calendar.
"""
scalar DateTime

type Group {
  alarms(after: AlarmWhereUniqueInput, before: AlarmWhereUniqueInput, first: Int, last: Int): [Alarm!]!
  id: Int!
  name: String!
  users(after: UserWhereUniqueInput, before: UserWhereUniqueInput, first: Int, last: Int): [User!]!
}

input GroupCreateInput {
  alarms: AlarmCreateManyWithoutGroupInput
  name: String!
  users: UserCreateManyWithoutGroupsInput
}

input GroupCreateManyWithoutUsersInput {
  connect: [GroupWhereUniqueInput!]
  create: [GroupCreateWithoutUsersInput!]
}

input GroupCreateOneWithoutAlarmsInput {
  connect: GroupWhereUniqueInput
  create: GroupCreateWithoutAlarmsInput
}

input GroupCreateWithoutAlarmsInput {
  name: String!
  users: UserCreateManyWithoutGroupsInput
}

input GroupCreateWithoutUsersInput {
  alarms: AlarmCreateManyWithoutGroupInput
  name: String!
}

input GroupListRelationFilter {
  every: GroupWhereInput
  none: GroupWhereInput
  some: GroupWhereInput
}

input GroupWhereInput {
  alarms: AlarmListRelationFilter
  AND: [GroupWhereInput!]
  id: IntFilter
  name: StringFilter
  NOT: [GroupWhereInput!]
  OR: [GroupWhereInput!]
  users: UserListRelationFilter
}

input GroupWhereUniqueInput {
  id: Int
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

"""
The `JSONObject` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSONObject

type Mutation {
  createOneAlarm(data: AlarmCreateInput!): Alarm!
  createOneGroup(data: GroupCreateInput!): Group!
  createOneUser(data: UserCreateInput!): User!
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

type Query {
  alarm(where: AlarmWhereUniqueInput!): Alarm
  group(where: GroupWhereUniqueInput!): Group
  groups(after: GroupWhereUniqueInput, before: GroupWhereUniqueInput, first: Int, last: Int, where: GroupWhereInput): [Group!]!
  user(where: UserWhereUniqueInput!): User
  users(after: UserWhereUniqueInput, before: UserWhereUniqueInput, first: Int, last: Int, orderBy: [UserOrderByInput!]): [User!]!
}

enum SortOrder {
  asc
  desc
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

type User {
  alarms(after: AlarmWhereUniqueInput, before: AlarmWhereUniqueInput, first: Int, last: Int): [Alarm!]!
  groups(after: GroupWhereUniqueInput, before: GroupWhereUniqueInput, first: Int, last: Int): [Group!]!
  id: Int!
  name: String!
}

input UserCreateInput {
  alarms: AlarmCreateManyWithoutUserInput
  groups: GroupCreateManyWithoutUsersInput
  name: String!
}

input UserCreateManyWithoutGroupsInput {
  connect: [UserWhereUniqueInput!]
  create: [UserCreateWithoutGroupsInput!]
}

input UserCreateOneWithoutAlarmsInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutAlarmsInput
}

input UserCreateWithoutAlarmsInput {
  groups: GroupCreateManyWithoutUsersInput
  name: String!
}

input UserCreateWithoutGroupsInput {
  alarms: AlarmCreateManyWithoutUserInput
  name: String!
}

input UserListRelationFilter {
  every: UserWhereInput
  none: UserWhereInput
  some: UserWhereInput
}

input UserOrderByInput {
  id: SortOrder
  name: SortOrder
}

input UserWhereInput {
  alarms: AlarmListRelationFilter
  AND: [UserWhereInput!]
  groups: GroupListRelationFilter
  id: IntFilter
  name: StringFilter
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
}

input UserWhereUniqueInput {
  id: Int
}
